/*
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package bitbucketv1

import (
	"io"
	"log"
	"net/http"
	"net/http/httptest"
	"os"
	"reflect"
	"testing"
	"time"

	"golang.org/x/net/context"

	sw "github.com/gfleury/go-bitbucket-v1/test/bb-mock-server/go"
)

var runIntegrationTests bool

func TestAAAAA(t *testing.T) {
	runIntegrationTests = os.Getenv("INTEGRATION") == "TRUE"

	if runIntegrationTests {
		go func() {
			log.Fatal(sw.RunServer(7990))
		}()
		time.Sleep(2 * time.Second)
	}
}

func generateContextCanceled() context.Context {
	basicAuth := BasicAuth{UserName: "", Password: ""}
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Millisecond)
	ctx = context.WithValue(ctx, ContextBasicAuth, basicAuth)
	defer cancel()
	return ctx
}

func generateContext() context.Context {
	basicAuth := BasicAuth{UserName: "admin", Password: "AdminPass"}
	ctx, _ := context.WithTimeout(context.Background(), 5*time.Minute)
	ctx = context.WithValue(ctx, ContextBasicAuth, basicAuth)
	//defer cancel()
	return ctx
}

func generateConfigFake() *APIClient {
	return NewAPIClient(
		generateContextCanceled(),
		NewConfiguration("https://stash.domain.com/rest"),
	)
}

func generateConfigRealLocalServer() *APIClient {
	return NewAPIClient(
		generateContext(),
		NewConfiguration("http://localhost:7990/rest"),
	)
}
func TestDefaultApiService_AddGroupToUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/users/add-group: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.AddGroupToUser()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.AddGroupToUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.AddGroupToUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_AddUserToGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		ctx context.Context
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{ctx: context.Background()}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/groups/add-user: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.AddUserToGroup()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.AddUserToGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.AddUserToGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_AddUserToGroups(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		name   string
		groups []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{name: "user", groups: []string{"group"}}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/users/add-groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.AddUserToGroups(tt.args.name, tt.args.groups)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.AddUserToGroups() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.AddUserToGroups() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_AddUsersToGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		ctx context.Context
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{ctx: context.Background()}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/groups/add-users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.AddUsersToGroup()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.AddUsersToGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.AddUsersToGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Approve(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/approve: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Approve(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Approve() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Approve() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_AssignParticipantRole(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/participants: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.AssignParticipantRole(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.AssignParticipantRole() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.AssignParticipantRole() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CanMerge(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/merge: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CanMerge(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CanMerge() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CanMerge() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_ClearSenderAddress(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/mail-server/sender-address: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.ClearSenderAddress()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.ClearSenderAddress() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.ClearSenderAddress() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_ClearUserCaptchaChallenge(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/users/captcha: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.ClearUserCaptchaChallenge(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.ClearUserCaptchaChallenge() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.ClearUserCaptchaChallenge() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CountPullRequestTasks(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestId  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/tasks/count: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CountPullRequestTasks(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CountPullRequestTasks() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CountPullRequestTasks() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Create(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests: context canceled"}, true, false},
		{"InvalidRequest", fields{client: generateConfigRealLocalServer()},
			args{projectKey: "PROJ",
				repositorySlug:    "repo1_test1",
				localVarOptionals: map[string]interface{}{"values": "values"}},
			&APIResponse{
				Message: "Status: 400 Bad Request, Body: {errors:[{context:null,exceptionName:null,message:title must be supplied for this request}]}",
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "title must be supplied for this request",
							"exceptionName": nil,
						},
					},
				},
			},
			true, true},
		{"ValidRequestNoBranch", fields{client: generateConfigRealLocalServer()},
			args{projectKey: "PROJ",
				repositorySlug: "repo1_test2",
				localVarOptionals: map[string]interface{}{
					"title":       "test PR",
					"description": "test Desc",
					"state":       "OPEN",
					"open":        true,
					"closed":      false,
					"fromRef": map[string]interface{}{
						"id": "refs/heads/feature",
						"repository": map[string]interface{}{
							"slug": "repo1",
							"project": map[string]interface{}{
								"key": "PROJ",
							},
						},
					},
					"toRef": map[string]interface{}{
						"id": "refs/heads/master",
						"repository": map[string]interface{}{
							"slug": "repo1",
							"project": map[string]interface{}{
								"key": "PROJ",
							},
						},
					},
					"locked": false,
				},
			},
			&APIResponse{
				Message: `Status: 404 Not Found, Body: {errors:[{context:null,exceptionName:com.atlassian.bitbucket.commit.NoSuchCommitException,message:Repository \repo1\ of project with key \PROJ\ has no branch \refs/heads/feature\}]}`,
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "Repository \"repo1\" of project with key \"PROJ\" has no branch \"refs/heads/feature\"",
							"exceptionName": "com.atlassian.bitbucket.commit.NoSuchCommitException",
						},
					},
				},
			},
			true, true},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Create(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Create() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreatePullRequest(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals PullRequest
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests: context canceled"}, true, false},
		{"InvalidRequest", fields{client: generateConfigRealLocalServer()},
			args{projectKey: "PROJ",
				repositorySlug:    "repo1_test1",
				localVarOptionals: PullRequest{},
			},
			&APIResponse{
				Message: "Status: 400 Bad Request, Body: {errors:[{context:null,exceptionName:null,message:title must be supplied for this request}]}",
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "title must be supplied for this request",
							"exceptionName": nil,
						},
					},
				},
			},
			true, true},
		{"ValidRequestNoBranch", fields{client: generateConfigRealLocalServer()},
			args{projectKey: "PROJ",
				repositorySlug: "repo1_test2",
				localVarOptionals: PullRequest{
					Title:       "test PR",
					Description: "test Desc",
					State:       "OPEN",
					Open:        true,
					Closed:      false,
					FromRef: PullRequestRef{
						ID: "refs/heads/feature",
						Repository: Repository{
							Slug: "repo1",
							Project: &Project{
								Key: "PROJ",
							},
						},
					},
					ToRef: PullRequestRef{
						ID: "refs/heads/master",
						Repository: Repository{
							Slug: "repo1",
							Project: &Project{
								Key: "PROJ",
							},
						},
					},
					Locked: false,
				},
			},
			&APIResponse{Message: `Status: 404 Not Found, Body: {errors:[{context:null,exceptionName:com.atlassian.bitbucket.commit.NoSuchCommitException,message:Repository \repo1\ of project with key \PROJ\ has no branch \refs/heads/feature\}]}`,
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "Repository \"repo1\" of project with key \"PROJ\" has no branch \"refs/heads/feature\"",
							"exceptionName": "com.atlassian.bitbucket.commit.NoSuchCommitException",
						},
					},
				},
			},
			true, true},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreatePullRequest(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Create() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoryPullRequests(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	tests := []struct {
		name                     string
		projectKey               string
		repositorySlug           string
		want                     *APIResponse
		updatePullRequestOptions *EditPullRequestOptions
		wantErr                  bool
		fields                   fields
	}{
		{
			projectKey:               "test",
			repositorySlug:           "repoTest",
			want:                     &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects/test/repos/repoTest/pull-requests: context canceled"},
			updatePullRequestOptions: &EditPullRequestOptions{},
			wantErr:                  true,
			fields:                   fields{client: generateConfigFake()},
		},
	}
	for _, tt := range tests {
		client := &DefaultApiService{
			client: tt.fields.client,
		}
		t.Run(tt.name, func(t *testing.T) {
			got, err := client.GetRepositoryPullRequests(tt.projectKey, tt.repositorySlug, nil)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Create() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdatePullRequest(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	tests := []struct {
		name                     string
		projectKey               string
		repositorySlug           string
		want                     *APIResponse
		updatePullRequestOptions *EditPullRequestOptions
		wantErr                  bool
		fields                   fields
	}{
		{
			projectKey:               "test",
			repositorySlug:           "repoTest",
			want:                     &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects/test/repos/repoTest/pull-requests/0: context canceled"},
			updatePullRequestOptions: &EditPullRequestOptions{},
			wantErr:                  true,
			fields:                   fields{client: generateConfigFake()},
		},
	}
	for _, tt := range tests {
		client := &DefaultApiService{
			client: tt.fields.client,
		}
		t.Run(tt.name, func(t *testing.T) {
			got, err := client.UpdatePullRequest(tt.projectKey, tt.repositorySlug, tt.updatePullRequestOptions)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Create() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Create() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateBranch(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//branches: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateBranch(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateBranch() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateBranch() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateComment(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//commits//comments: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateComment(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateComment() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateCommentWithComment(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		comment           Comment
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//commits//comments: context canceled"}, true, false},
		{"simpleComment", fields{client: generateConfigRealLocalServer()},
			args{projectKey: "PROJ",
				repositorySlug: "repo1",
				commitId:       "657f55ce41710f9bfde15c374837136728fae9d9e0eca0b97cb7bfea5095af30",
				comment:        Comment{Text: "Simple comment"},
			},
			&APIResponse{Message: `Status: 404 Not Found, Body: {errors:[{context:null,exceptionName:com.atlassian.bitbucket.commit.NoSuchCommitException,message:Commit '657f55ce41710f9bfde15c374837136728fae9d9e0eca0b97cb7bfea5095af30' does not exist in repository 'repo1'.}]}`,
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "Commit '657f55ce41710f9bfde15c374837136728fae9d9e0eca0b97cb7bfea5095af30' does not exist in repository 'repo1'.",
							"exceptionName": "com.atlassian.bitbucket.commit.NoSuchCommitException",
						},
					},
				},
			},
			true, true,
		},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateCommentWithComment(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.comment, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateCommentWithComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateCommentWithComment() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreatePullRequestComment(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		repositorySlug           string
		pullRequestID            int
		comment                  Comment
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/comments: context canceled"}, true, false},
		{"simpleComment", fields{client: generateConfigRealLocalServer()},
			args{projectKey: "PROJ",
				repositorySlug:           "repo1",
				pullRequestID:            1,
				comment:                  Comment{Text: "Simple comment"},
				localVarHTTPContentTypes: []string{"application/json"},
			},
			&APIResponse{Message: `Status: 404 Not Found, Body: {errors:[{context:null,exceptionName:com.atlassian.bitbucket.pull.NoSuchPullRequestException,message:Pull request 1 does not exist in PROJ/repo1.}]}`,
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "Pull request 1 does not exist in PROJ/repo1.",
							"exceptionName": "com.atlassian.bitbucket.pull.NoSuchPullRequestException",
						},
					},
				},
			},
			true, true,
		},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreatePullRequestComment(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.comment, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreatePullRequestComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreatePullRequestComment() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateGroup(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateProject(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		body Project
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{Project{}}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateProject(tt.args.body)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateProject() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateProject() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
		repo       Repository
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateRepository(tt.args.projectKey, tt.args.repo)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateRepositoryWithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		localVarPostBody         interface{}
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateRepositoryWithOptions(tt.args.projectKey, tt.args.localVarPostBody, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateRepositoryWithOptions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateRepositoryWithOptions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreatePullRequestWithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey       string
		repo             string
		localVarPostBody interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreatePullRequestWithOptions(tt.args.projectKey, tt.args.repo, tt.args.localVarPostBody)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreatePullRequestWithOptions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreatePullRequestWithOptions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateTag(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//tags: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateTag(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateTag() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateTag() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateTask(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/tasks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateTask()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateTask() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateTask() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/users: context canceled"}, true, false},
		{"GoodUser", fields{client: generateConfigFake()}, args{localVarOptionals: map[string]interface{}{"name": "username"}}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/users?name=username: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateUser(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateWebhook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		repositorySlug           string
		localVarPostBody         interface{}
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//webhooks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateWebhook(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarPostBody, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateWebhook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateWebhook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Decline(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/decline: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Decline(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Decline() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Decline() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Delete(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0: context canceled"}, true, false},
		{"wrongType", fields{
			client: generateConfigRealLocalServer()},
			args{
				projectKey:     "PROJ",
				repositorySlug: "repo1",
				pullRequestID:  -1,
			},
			&APIResponse{
				Message: "Status: 404 Not Found, Body: {errors:[{context:null,exceptionName:com.atlassian.bitbucket.pull.NoSuchPullRequestException,message:No pull request exists with ID -1 for this repository 1}]}",
				Values: map[string]interface{}{
					"errors": []interface{}{
						map[string]interface{}{
							"context":       nil,
							"message":       "No pull request exists with ID -1 for this repository 1",
							"exceptionName": "com.atlassian.bitbucket.pull.NoSuchPullRequestException",
						},
					},
				},
			},
			true, true},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Delete(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Delete() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Delete() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteAvatar(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		userSlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/users//avatar.png: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteAvatar(tt.args.userSlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteAvatar() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteAvatar() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteComment(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		commentId         int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//commits//comments/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteComment(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.commentId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteComment() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteComment_2(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestId     int
		commentId         int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/comments/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteComment_2(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestId, tt.args.commentId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteComment_2() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteComment_2() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteGroup(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteMailConfig(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/mail-server: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteMailConfig()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteMailConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteMailConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteProject(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteProject(tt.args.projectKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteProject() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteProject() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteRepository(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteRepositoryHook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteRepositoryHook(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteRepositoryHook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteRepositoryHook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteTask(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		taskId int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/tasks/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteTask(tt.args.taskId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteTask() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteTask() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteUser(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DeleteWebhook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		webhookId      int32
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DeleteWebhook(tt.args.projectKey, tt.args.repositorySlug, tt.args.webhookId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DeleteWebhook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DeleteWebhook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DisableHook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks//enabled: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DisableHook(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DisableHook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DisableHook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_DisableHook_3(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
		hookKey    string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//settings/hooks//enabled: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.DisableHook_3(tt.args.projectKey, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.DisableHook_3() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.DisableHook_3() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_EditFile(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		path           string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//browse/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.EditFile(tt.args.projectKey, tt.args.repositorySlug, tt.args.path)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.EditFile() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.EditFile() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_EnableHook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		hookKey           string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks//enabled: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.EnableHook(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.EnableHook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.EnableHook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_EnableHook_4(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		hookKey           string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//settings/hooks//enabled: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.EnableHook_4(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.EnableHook_4() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.EnableHook_4() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_EnableHook_4_WithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		hookKey           string
		localVarOptionals map[string]interface{}
		localVarPostBody  map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//settings/hooks//enabled: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.EnableHook_4_WithOptions(tt.args.projectKey, tt.args.hookKey, tt.args.localVarOptionals, tt.args.localVarPostBody)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.EnableHook_4_WithOptions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.EnableHook_4_WithOptions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_FindGroupsForUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/users/more-members: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.FindGroupsForUser(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.FindGroupsForUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.FindGroupsForUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_FindOtherGroupsForUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/users/more-non-members: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.FindOtherGroupsForUser(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.FindOtherGroupsForUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.FindOtherGroupsForUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_FindUsersInGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/groups/more-members: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.FindUsersInGroup(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.FindUsersInGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.FindUsersInGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_FindUsersNotInGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/groups/more-non-members: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.FindUsersNotInGroup(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.FindUsersNotInGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.FindUsersNotInGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_FindWebhooks(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//webhooks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.FindWebhooks(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.FindWebhooks() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.FindWebhooks() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_ForkRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		repositorySlug           string
		localVarPostBody         interface{}
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.ForkRepository(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarPostBody, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.ForkRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.ForkRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Get(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/license: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetLicense()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Get() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Get() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetActivities(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/activities: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetActivities(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetActivities() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetActivities() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetApplicationProperties(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/application-properties: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetApplicationProperties()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetApplicationProperties() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetApplicationProperties() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetArchive(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		localVarOptionals map[string]interface{}
		writer            io.Writer
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//archive: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetArchive(tt.args.project, tt.args.repository, tt.args.localVarOptionals, tt.args.writer)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetArchive() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetArchive() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetAvatar(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		hookKey           string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/hooks//avatar: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetAvatar(tt.args.hookKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetAvatar() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetAvatar() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetBranches(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//branches: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetBranches(tt.args.project, tt.args.repository, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetBranches() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetBranches() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetBranchesPagination(t *testing.T) {
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		switch r.RequestURI {
		case "/api/1.0/projects/PROJECT/repos/REPO/branches?limit=100&start=0":
			_, err := io.WriteString(w, `{
				"size": 1,
				"limit": 100,
				"isLastPage": true,
				"values": [
					{
						"id": "refs/heads/main",
						"displayId": "main",
						"type": "BRANCH",
						"latestCommit": "8d51122def5632836d1cb1026e879069e10a1e13",
						"latestChangeset": "8d51122def5632836d1cb1026e879069e10a1e13",
						"isDefault": true
					}
				],
				"start": 0
			}`)
			if err != nil {
				t.Errorf("DefaultApiService.GetBranches() error = i/o error %v", err)
			}
		default:
			t.Errorf("DefaultApiService.GetBranches() error = unhandled request %s", r.RequestURI)
		}
	}))
	defer ts.Close()

	client := NewAPIClient(
		context.TODO(),
		NewConfiguration(ts.URL),
	)
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"limitAndStartSet", fields{client: client}, args{
			project: "PROJECT", repository: "REPO",
			localVarOptionals: map[string]interface{}{
				"limit": 100,
				"start": 0,
			}}, nil, false, false},
		{"incorrectLimit", fields{client: client}, args{
			project: "PROJECT", repository: "REPO",
			localVarOptionals: map[string]interface{}{
				"limit": "wrong",
			}}, nil, true, false},
		{"incorrectStart", fields{client: client}, args{
			project: "PROJECT", repository: "REPO",
			localVarOptionals: map[string]interface{}{
				"start": "wrong",
			}}, nil, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			_, err := a.GetBranches(tt.args.project, tt.args.repository, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetBranches() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
		})
	}
}

func TestDefaultApiService_GetChanges(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string

		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//changes: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetChanges(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetChanges() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetChanges() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetChanges_5(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits//changes: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetChanges_5(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetChanges_5() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetChanges_5() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetComment(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		commitId       string
		commentId      int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits//comments/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetComment(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.commentId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetComment() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetComment_6(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestId  int
		commentId      int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/comments/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetComment_6(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestId, tt.args.commentId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetComment_6() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetComment_6() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetComments(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string

		commitId          string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits//comments: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetComments(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetComments() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetComments() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetComments_7(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestId     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/comments: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetComments_7(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetComments_7() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetComments_7() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommit(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommit(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommit() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommit() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommits(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommits(tt.args.project, tt.args.repository, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommits() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommits() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommits_8(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/commits: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommits_8(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommits_8() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommits_8() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetContent(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//browse: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetContent(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetContent() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetContent() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetContent_9(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//browse/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetContent_9(tt.args.projectKey, tt.args.repositorySlug, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetContent_9() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetContent_9() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetContent_10(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//raw: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetContent_10(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetContent_10() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetContent_10() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetContent_11(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//raw/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRawContent(tt.args.projectKey, tt.args.repositorySlug, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRawContent() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRawContent() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetDefaultBranch(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//branches/default: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetDefaultBranch(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetDefaultBranch() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetDefaultBranch() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetForkedRepositories(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//forks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetForkedRepositories(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetForkedRepositories() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetForkedRepositories() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroups(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroups(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroups() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroups() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroupsWithAnyPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroupsWithAnyPermission(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroupsWithAnyPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroupsWithAnyPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroupsWithAnyPermission_12(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroupsWithAnyPermission_12(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroupsWithAnyPermission_12() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroupsWithAnyPermission_12() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroupsWithAnyPermission_13(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroupsWithAnyPermission_13(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroupsWithAnyPermission_13() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroupsWithAnyPermission_13() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroupsWithoutAnyPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/permissions/groups/none: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroupsWithoutAnyPermission(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroupsWithoutAnyPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroupsWithoutAnyPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroupsWithoutAnyPermission_14(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//permissions/groups/none: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroupsWithoutAnyPermission_14(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroupsWithoutAnyPermission_14() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroupsWithoutAnyPermission_14() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroupsWithoutAnyPermission_15(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//permissions/groups/none: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroupsWithoutAnyPermission_15(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroupsWithoutAnyPermission_15() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroupsWithoutAnyPermission_15() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetGroups_16(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetGroups_16(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetGroups_16() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetGroups_16() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetInformation(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/cluster: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetInformation()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetInformation() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetInformation() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetLatestInvocation(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		webhookId         int32
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/0/latest: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetLatestInvocation(tt.args.projectKey, tt.args.repositorySlug, tt.args.webhookId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetLatestInvocation() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetLatestInvocation() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetLevel(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		loggerName string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/logs/logger/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetLevel(tt.args.loggerName)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetLevel() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetLevel() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetMailConfig(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/mail-server: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetMailConfig()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetMailConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetMailConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetMergeConfig(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		scmId string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/pull-requests/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetMergeConfig(tt.args.scmId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetMergeConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetMergeConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestsPage(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestsPage(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestsPage() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestsPage() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetProject(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		key string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{key: "7BprojectKey"}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects/7BprojectKey: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetProject(tt.args.key)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetProject() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetProject() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetProjectAvatar(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//avatar.png: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetProjectAvatar(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetProjectAvatar() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetProjectAvatar() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetProjects(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}

	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		// Network errors
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{localVarOptionals: map[string]interface{}{}}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetProjects(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetProjects() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetProjects() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestCount(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/inbox/pull-requests/count: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestCount()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestCount() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestCount() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestSettings(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//settings/pull-requests: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestSettings(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestSettings() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestSettings() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestSettings_17(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		scmId          string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//settings/pull-requests/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestSettings_17(tt.args.projectKey, tt.args.repositorySlug, tt.args.scmId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestSettings_17() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestSettings_17() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestSuggestions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/dashboard/pull-request-suggestions: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestSuggestions(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestSuggestions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestSuggestions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestTasks(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/tasks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestTasks(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestTasks() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestTasks() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequests(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/dashboard/pull-requests: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequests(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequests() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequests() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequests_18(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/inbox/pull-requests: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequests_18(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequests_18() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequests_18() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRelatedRepositories(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//related: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRelatedRepositories(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRelatedRepositories() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRelatedRepositories() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositories(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositories(tt.args.projectKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositories() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositories() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoriesWithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositoriesWithOptions(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositoriesWithOptions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositoriesWithOptions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoriesRecentlyAccessed(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/profile/recent/repos: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositoriesRecentlyAccessed(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositoriesRecentlyAccessed() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositoriesRecentlyAccessed() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositories_19(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/repos: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositories_19(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositories_19() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositories_19() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepository(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUserRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		username       string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/users//repos/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUserRepository(tt.args.username, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUserRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUserRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequest(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequest(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequest() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequest() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestActivity(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/activities: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestActivity(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestActivity() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestActivity() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestActivityWithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/activities: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestActivityWithOptions(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestActivity() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestActivity() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestCommits(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/commits: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestCommits(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestCommits() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestCommits() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestCommitsWithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/commits: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestCommitsWithOptions(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestCommitsWithOptions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestCommitsWithOptions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommitBuildStatuses(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		commitSHA string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/build-status/1.0/commits/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommitBuildStatuses(tt.args.commitSHA)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommitBuildStatuses() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommitBuildStatuses() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoryHook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositoryHook(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositoryHook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositoryHook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoryHook_20(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//settings/hooks/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositoryHook_20(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositoryHook_20() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositoryHook_20() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoryHooks(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositoryHooks(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositoryHooks() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositoryHooks() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRepositoryHooks_21(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//settings/hooks: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRepositoryHooks_21(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRepositoryHooks_21() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRepositoryHooks_21() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetRootLevel(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/logs/rootLogger: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetRootLevel()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetRootLevel() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetRootLevel() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetSenderAddress(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/mail-server/sender-address: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetSenderAddress()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetSenderAddress() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetSenderAddress() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetSettings(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks//settings: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetSettings(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetSettings() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetSettings() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetSettings_22(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//settings/hooks//settings: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetSettings_22(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetSettings_22() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetSettings_22() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetStatistics(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		webhookId         int32
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/0/statistics: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetStatistics(tt.args.projectKey, tt.args.repositorySlug, tt.args.webhookId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetStatistics() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetStatistics() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetStatisticsSummary(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		webhookId      int32
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/0/statistics/summary: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetStatisticsSummary(tt.args.projectKey, tt.args.repositorySlug, tt.args.webhookId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetStatisticsSummary() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetStatisticsSummary() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetTag(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		name           string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//tags/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetTag(tt.args.projectKey, tt.args.repositorySlug, tt.args.name)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetTag() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetTag() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetTags(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//tags: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetTags(tt.args.project, tt.args.repository, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetTags() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetTags() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetTask(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		taskId int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/tasks/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetTask(tt.args.taskId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetTask() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetTask() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetSSHKeys(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		user string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/ssh/1.0/keys: context canceled"}, true, false},
		{"realLocalServer", fields{client: generateConfigRealLocalServer()}, args{},
			&APIResponse{Values: map[string]interface{}{
				"size":       float64(1),
				"limit":      float64(25),
				"isLastPage": true,
				"values": []interface{}{
					map[string]interface{}{
						"id":    float64(1),
						"text":  "ssh-rsa AAAAB3... me@127.0.0.1",
						"label": "me@127.0.0.1",
					},
				},
				"start": float64(0),
			}},
			false, true},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetSSHKeys(tt.args.user)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetSSHKeys() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetSSHKeys() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_CreateSSHKey(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/ssh/1.0/keys: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.CreateSSHKey(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.CreateSSHKey() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.CreateSSHKey() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		username string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/users/: context canceled"}, true, false},
		{"GetRealUser", fields{client: generateConfigRealLocalServer()},
			args{
				username: "admin",
			},
			&APIResponse{Values: map[string]interface{}{
				"active":       true,
				"displayName":  "admin",
				"emailAddress": "admin@example.com",
				"id":           float64(1),
				"links": map[string]interface{}{
					"self": []interface{}{map[string]interface{}{"href": "http://localhost:7990/users/admin"}},
				},
				"name": "admin", "slug": "admin", "type": "NORMAL"},
			},
			false, true},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUser(tt.args.username)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != nil {
				got.Response = nil
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUserSettings(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		userSlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/users//settings: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUserSettings(tt.args.userSlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUserSettings() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUserSettings() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsers(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsers(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsers() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsers() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsersWithAnyPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsersWithAnyPermission(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsersWithAnyPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsersWithAnyPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsersWithAnyPermission_23(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsersWithAnyPermission_23(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsersWithAnyPermission_23() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsersWithAnyPermission_23() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsersWithAnyPermission_24(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsersWithAnyPermission_24(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsersWithAnyPermission_24() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsersWithAnyPermission_24() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsersWithoutAnyPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/admin/permissions/users/none: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsersWithoutAnyPermission(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsersWithoutAnyPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsersWithoutAnyPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsersWithoutPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string

		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//permissions/users/none: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsersWithoutPermission(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsersWithoutPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsersWithoutPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsersWithoutPermission_25(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//permissions/users/none: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsersWithoutPermission_25(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsersWithoutPermission_25() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsersWithoutPermission_25() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetUsers_26(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetUsers_26(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetUsers_26() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetUsers_26() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetWebhook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		webhookId         int32
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetWebhook(tt.args.projectKey, tt.args.repositorySlug, tt.args.webhookId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetWebhook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetWebhook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Get_27(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Get_27(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Get_27() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Get_27() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_HasAllUserPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
		permission string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//permissions//all: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.HasAllUserPermission(tt.args.projectKey, tt.args.permission)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.HasAllUserPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.HasAllUserPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_ListParticipants(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string

		pullRequestID int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/participants: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.ListParticipants(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.ListParticipants() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.ListParticipants() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Merge(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		repositorySlug           string
		pullRequestID            int
		localVarOptionals        map[string]interface{}
		localVarPostBody         interface{}
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/merge: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Merge(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals, tt.args.localVarPostBody, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Merge() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Merge() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_ModifyAllUserPermission(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string

		permission        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//permissions//all: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.ModifyAllUserPermission(tt.args.projectKey, tt.args.repositorySlug, tt.args.permission, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.ModifyAllUserPermission() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.ModifyAllUserPermission() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Preview(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/markup/preview: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Preview(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Preview() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Preview() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RemoveGroupFromUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/users/remove-group: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RemoveGroupFromUser()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RemoveGroupFromUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RemoveGroupFromUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RemoveUserFromGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/groups/remove-user: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RemoveUserFromGroup()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RemoveUserFromGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RemoveUserFromGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RenameUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/users/rename: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RenameUser()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RenameUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RenameUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Reopen(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/reopen: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Reopen(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Reopen() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Reopen() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RetryCreateRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//recreate: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RetryCreateRepository(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RetryCreateRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RetryCreateRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RevokePermissionsForGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RevokePermissionsForGroup(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RevokePermissionsForGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RevokePermissionsForGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RevokePermissionsForGroup_28(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RevokePermissionsForGroup_28(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RevokePermissionsForGroup_28() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RevokePermissionsForGroup_28() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RevokePermissionsForGroup_29(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RevokePermissionsForGroup_29(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RevokePermissionsForGroup_29() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RevokePermissionsForGroup_29() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RevokePermissionsForUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/admin/permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RevokePermissionsForUser(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RevokePermissionsForUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RevokePermissionsForUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RevokePermissionsForUser_30(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RevokePermissionsForUser_30(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RevokePermissionsForUser_30() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RevokePermissionsForUser_30() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_RevokePermissionsForUser_31(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.RevokePermissionsForUser_31(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.RevokePermissionsForUser_31() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.RevokePermissionsForUser_31() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Search(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//participants: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Search(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Search() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Search() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetDefaultBranch(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		branchRef      string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//branches/default: context canceled"}, true, false},
		{"goodRequest", fields{client: generateConfigRealLocalServer()}, args{"PRJ", "repo1", "ref/branch/master"}, &APIResponse{Values: map[string]interface{}{}}, false, true},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetDefaultBranch(tt.args.projectKey, tt.args.repositorySlug, tt.args.branchRef)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetDefaultBranch() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			got.Response = nil
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetDefaultBranch() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetLevel(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		levelName  string
		loggerName string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/logs/logger//: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetLevel(tt.args.levelName, tt.args.loggerName)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetLevel() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetLevel() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetMailConfig(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/admin/mail-server: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetMailConfig()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetMailConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetMailConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetMergeConfig(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		scmId string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/pull-requests/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetMergeConfig(tt.args.scmId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetMergeConfig() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetMergeConfig() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetPermissionForGroup(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetPermissionForGroup(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetPermissionForGroup() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetPermissionForGroup() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetPermissionForGroups(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/admin/permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetPermissionForGroups(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetPermissionForGroups() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetPermissionForGroups() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetPermissionForGroups_32(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//permissions/groups: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetPermissionForGroups_32(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetPermissionForGroups_32() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetPermissionForGroups_32() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetPermissionForUser(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetPermissionForUser(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetPermissionForUser() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetPermissionForUser() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetPermissionForUsers(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/admin/permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetPermissionForUsers(tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetPermissionForUsers() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetPermissionForUsers() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetPermissionForUsers_33(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//permissions/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetPermissionForUsers_33(tt.args.projectKey, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetPermissionForUsers_33() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetPermissionForUsers_33() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetRootLevel(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		levelName string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/logs/rootLogger/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetRootLevel(tt.args.levelName)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetRootLevel() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetRootLevel() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetSenderAddress(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/admin/mail-server/sender-address: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetSenderAddress()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetSenderAddress() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetSenderAddress() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetSettings(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//settings/hooks//settings: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetSettings(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetSettings() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetSettings() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetSettings_34(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		hookKey        string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//settings/hooks//settings: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetSettings_34(tt.args.projectKey, tt.args.repositorySlug, tt.args.hookKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetSettings_34() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetSettings_34() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Stream(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//last-modified: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Stream(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Stream() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Stream() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamChanges(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//compare/changes: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamChanges(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamChanges() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamChanges() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamChanges_35(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/changes: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamChanges_35(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamChanges_35() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamChanges_35() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamCommits(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//compare/commits: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamCommits(tt.args.project, tt.args.repository, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamCommits() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamCommits() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamDiff(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits//diff: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamDiff(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamDiff() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamDiff() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamDiff_36(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		commitId          string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//commits//diff/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamDiff_36(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamDiff_36() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamDiff_36() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamDiff_37(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		project           string
		repository        string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//compare/diff: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamDiff_37(tt.args.project, tt.args.repository, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamDiff_37() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamDiff_37() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamDiff_38(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//diff: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamDiff_38(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamDiff_38() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamDiff_38() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamDiff_39(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//diff/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamDiff_39(tt.args.projectKey, tt.args.repositorySlug, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamDiff_39() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamDiff_39() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetPullRequestDiff(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{
			projectKey:     "projectKey",
			repositorySlug: "repositorySlug",
			pullRequestID:  1,
		}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects/projectKey/repos/repositorySlug/pull-requests/1/diff: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetPullRequestDiff(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetPullRequestDiff() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetPullRequestDiff() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamDiff_41(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/diff/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamDiff_41(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamDiff_41() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamDiff_41() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamFiles(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//files: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamFiles(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamFiles() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamFiles() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_StreamFiles_42(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//files/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.StreamFiles_42(tt.args.projectKey, tt.args.repositorySlug, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.StreamFiles_42() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.StreamFiles_42() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Stream_43(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		path              string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/api/1.0/projects//repos//last-modified/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Stream_43(tt.args.projectKey, tt.args.repositorySlug, tt.args.path, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Stream_43() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Stream_43() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestWebhook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/test: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.TestWebhook(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.TestWebhook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.TestWebhook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UnassignParticipantRole(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey        string
		repositorySlug    string
		pullRequestID     int
		localVarOptionals map[string]interface{}
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/participants: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UnassignParticipantRole(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.localVarOptionals)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UnassignParticipantRole() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UnassignParticipantRole() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UnassignParticipantRole_44(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
		userSlug       string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/participants/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UnassignParticipantRole_44(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.userSlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UnassignParticipantRole_44() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UnassignParticipantRole_44() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Unwatch(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		commitId       string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//commits//watch: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Unwatch(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Unwatch() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Unwatch() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Unwatch_45(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/watch: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Unwatch_45(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Unwatch_45() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Unwatch_45() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Update(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/admin/license: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Update()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Update() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Update() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateComment(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		commitId       string
		commentId      int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//commits//comments/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateComment(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId, tt.args.commentId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateComment() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateComment() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateComment_46(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
		commentId      int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/comments/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateComment_46(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.commentId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateComment_46() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateComment_46() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateProject(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateProject(tt.args.projectKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateProject() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateProject() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdatePullRequestSettings(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//settings/pull-requests: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdatePullRequestSettings(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdatePullRequestSettings() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdatePullRequestSettings() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdatePullRequestSettings_47(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		scmId          string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//settings/pull-requests/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdatePullRequestSettings_47(tt.args.projectKey, tt.args.repositorySlug, tt.args.scmId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdatePullRequestSettings_47() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdatePullRequestSettings_47() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateRepository(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateRepository(tt.args.projectKey, tt.args.repositorySlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateRepository() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateRepository() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateRepositoryWithOptions(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		repositorySlug           string
		localVarPostBody         interface{}
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateRepositoryWithOptions(tt.args.projectKey, tt.args.repositorySlug, tt.args.localVarPostBody, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateRepositoryWithOptions() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateRepositoryWithOptions() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateSettings(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		userSlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/users//settings: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateSettings(tt.args.userSlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateSettings() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateSettings() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateStatus(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
		userSlug       string
		participant    UserWithMetadata
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/participants/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateStatus(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID, tt.args.userSlug, tt.args.participant)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateStatus() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateStatus() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateTask(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		taskId int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/tasks/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateTask(tt.args.taskId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateTask() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateTask() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateUserDetails(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/admin/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateUserDetails()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateUserDetails() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateUserDetails() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateUserDetails_48(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/users: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateUserDetails_48()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateUserDetails_48() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateUserDetails_48() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateUserPassword(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/admin/users/credentials: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateUserPassword()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateUserPassword() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateUserPassword() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateUserPassword_49(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/users/credentials: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateUserPassword_49()
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateUserPassword_49() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateUserPassword_49() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UpdateWebhook(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey               string
		repositorySlug           string
		webhookId                int32
		localVarPostBody         interface{}
		localVarHTTPContentTypes []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//webhooks/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UpdateWebhook(tt.args.projectKey, tt.args.repositorySlug, tt.args.webhookId, tt.args.localVarPostBody, tt.args.localVarHTTPContentTypes)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UpdateWebhook() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UpdateWebhook() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Update_50(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Put https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Update_50(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Update_50() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Update_50() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UploadAvatar(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//avatar.png: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UploadAvatar(tt.args.projectKey)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UploadAvatar() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UploadAvatar() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_UploadAvatar_51(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		userSlug string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/users//avatar.png: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.UploadAvatar_51(tt.args.userSlug)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.UploadAvatar_51() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.UploadAvatar_51() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Watch(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		commitId       string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//commits//watch: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Watch(tt.args.projectKey, tt.args.repositorySlug, tt.args.commitId)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Watch() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Watch() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_Watch_52(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/watch: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.Watch_52(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.Watch_52() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.Watch_52() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_WithdrawApproval(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		projectKey     string
		repositorySlug string
		pullRequestID  int
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Delete https://stash.domain.com/rest/api/1.0/projects//repos//pull-requests/0/approve: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.WithdrawApproval(tt.args.projectKey, tt.args.repositorySlug, tt.args.pullRequestID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.WithdrawApproval() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.WithdrawApproval() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommitStats(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		commitID string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/build-status/1.0/commits/stats/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommitStats(tt.args.commitID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommitStats() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommitStats() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommitStatus(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		commitID string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Get https://stash.domain.com/rest/build-status/1.0/commits/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommitStatus(tt.args.commitID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommitStatus() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommitStatus() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_GetCommitsStats(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		commitsID []string
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/build-status/1.0/commits/stats: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.GetCommitsStats(tt.args.commitsID)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.GetCommitsStats() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.GetCommitsStats() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SetCommitStatus(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		commitID    string
		buildStatus BuildStatus
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{}, &APIResponse{Message: "Post https://stash.domain.com/rest/build-status/1.0/commits/: context canceled"}, true, false},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SetCommitStatus(tt.args.commitID, tt.args.buildStatus)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SetCommitStatus() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SetCommitStatus() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestDefaultApiService_SearchCode(t *testing.T) {
	type fields struct {
		client *APIClient
	}
	type args struct {
		query SearchQuery
	}
	tests := []struct {
		name                     string
		fields                   fields
		args                     args
		want                     *APIResponse
		wantErr, integrationTest bool
	}{
		{"networkErrorContextExceeded", fields{client: generateConfigFake()}, args{query: SearchQuery{}}, &APIResponse{Message: "Post https://stash.domain.com/rest/search/latest/search: context canceled"}, true, false},
		{"GoodEmptySearch",
			fields{client: generateConfigRealLocalServer()},
			args{query: SearchQuery{
				Query: "git clone",
				Limits: Limits{
					Primary:   10,
					Secondary: 100,
				},
			}},
			&APIResponse{
				Values: map[string]interface{}{
					"query": map[string]interface{}{
						"substituted": false,
					},
					"code": map[string]interface{}{
						"category":   "primary",
						"count":      float64(0),
						"isLastPage": true,
						"nextStart":  float64(10),
						"start":      float64(0),
						"values":     []interface{}{},
					},
					"scope": map[string]interface{}{
						"type": "GLOBAL",
					},
				},
			},
			false,
			true,
		},
	}
	for _, tt := range tests {
		if tt.integrationTest != runIntegrationTests {
			continue
		}
		t.Run(tt.name, func(t *testing.T) {
			a := &DefaultApiService{
				client: tt.fields.client,
			}
			got, err := a.SearchCode(tt.args.query)
			if (err != nil) != tt.wantErr {
				t.Errorf("DefaultApiService.SearchCode() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			got.Response = nil
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("DefaultApiService.SearchCode() = %v, want %v", got, tt.want)
			}
		})
	}
}
